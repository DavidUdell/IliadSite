<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Hilbert Snake</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    .wrap { display:flex; flex-direction:column; gap:10px; align-items:center; }
    canvas { background:#000000; border-radius:14px; box-shadow: 0 10px 30px rgb(0, 0, 0); }
  </style>
</head>
<body>
  <div class="wrap">
    <canvas id="c" width="900" height="900"></canvas>
  </div>

  <script>
    // Parameters
    const ORDER = 8;                 // Hilbert order
    const MARGIN = 24;               // canvas pixels of padding
    const STEP_PER_FRAME = 10;        // points advanced per frame
    const LINE_WIDTH = 1;            // snake thickness


    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');

    // For HiDPI displays
    (function scaleCanvasForDPR() {
      const dpr = Math.max(1, window.devicePixelRatio || 1);
      const { width, height } = canvas;
      canvas.style.width = width + "px";
      canvas.style.height = height + "px";
      canvas.width = Math.floor(width * dpr);
      canvas.height = Math.floor(height * dpr);
      ctx.scale(dpr, dpr);
    })();

    const SIZE = 1 << ORDER;                 // grid width/height
    const TOTAL = SIZE * SIZE;               // total points
    const W = canvas.clientWidth;
    const H = canvas.clientHeight;
    const step = Math.min((W - 2*MARGIN) / (SIZE - 1), (H - 2*MARGIN) / (SIZE - 1));

    // Map grid (x,y) -> canvas pixels
    function toPx(x, y) {
      const px = MARGIN + x * step;
      const py = H - (MARGIN + y * step);
      return [px, py];
    }

    // Rotate a quadrant
    function rot(n, x, y, rx, ry) {
      if (ry === 0) {
        if (rx === 1) {
          x = n - 1 - x;
          y = n - 1 - y;
        }

        const t = x; x = y; y = t;
      }
      return [x, y];
    }

    // Convert distance d along the Hilbert curve to (x,y) in [0, SIZE-1]^2
    function d2xy(n, d) {
      let x = 0, y = 0;
      let t = d;
      for (let s = 1; s < n; s <<= 1) {
        const rx = (t >> 1) & 1;
        const ry = (t ^ rx) & 1;
        [x, y] = rot(s, x, y, rx, ry);
        x += s * rx;
        y += s * ry;
        t >>= 2;
      }
      return [x, y];
    }

    // Build the path points. We horizontally mirror so we START at bottom-right and first step goes UP.
    const pts = new Array(TOTAL);
    for (let d = 0; d < TOTAL; d++) {
      let [x, y] = d2xy(SIZE, d);       // standard: starts at bottom-left and goes up
      x = (SIZE - 1) - x;               // mirror horizontally -> start bottom-right, going up
      pts[d] = toPx(x, y);
    }

    // Animation state
    let i = 1; // head index into pts (segment head is between pts[i-1] -> pts[i])

    function draw() {
      ctx.clearRect(0, 0, W, H);

      // Draw snake tail with fading alpha
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      const tailStart = 1;
      for (let j = tailStart; j <= i; j++) {
        const a = (j - tailStart) / Math.max(1, (i - tailStart));
        ctx.globalAlpha = Math.pow(1 - a, 1.6);     // ease-out fade (diffuse out)
        ctx.lineWidth = LINE_WIDTH;
        ctx.beginPath();
        const [x0, y0] = pts[j - 1];
        const [x1, y1] = pts[j];
        ctx.moveTo(x0, y0);
        ctx.lineTo(x1, y1);
        ctx.strokeStyle = '#008900';
        ctx.stroke();
      }

      // Advance head
      i += STEP_PER_FRAME;
      if (i >= TOTAL) {
        // Animation completed - stop here
        return;
      }

      requestAnimationFrame(draw);
    }

    draw();
  </script>
</body>
</html>

