<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap">
    <title>Iliad</title>
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg">
    <link rel="icon" type="image/png" href="images/favicon.png">
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <!-- Background animation canvas -->
    <canvas id="background-canvas"></canvas>

<header>
    <nav>
        <div class="nav-links">
            <a href="index.html">Home</a>
            <a href="events.html">Events</a>
            <a href="team.html">Team</a>
            <a href="contact.html">Contact</a>
            <a href="about.html">About</a>
        </div>
        <div class="theme-toggle">
            <label class="theme-switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </nav>
</header>

<main>
    <div class="title-main">Iliad</div>

    <p>Iliad is an applied mathematics research nonprofit dedicated to
    advancing foundational research in AI alignment theory. We organize the <a
    href="https://www.iliadconference.com/">
    Iliad conference</a> series, the leading AI alignment theory conference,
    alongside a range of other conferences and events in the field.</p>

    <p>We collaborate with researchers at:</p>
    <div class="partner-logos">
        <img src="images/UNB_light_mode.svg" class="partner-logo" id="unb-logo"
        style="position: relative; bottom: 12px;">
        <img src="images/Sussex_light_mode.svg" class="partner-logo"
        id="sussex-logo" style="transform: scale(1.25)">
        <img src="images/UDE_light_mode.svg" class="partner-logo" id="ude-logo"
        style="transform: scale(0.96); position: relative; left: 3px;">
    </div>

    <p>and are financially supported by:</p>
    <div class="partner-logos">
        <img src="images/SFF_light_mode.svg" class="partner-logo" id="sff-logo"
             style="position: relative; left: -4px;">
    </div>
</main>

<footer>
    <div class="footer-content">
        <small class="footer-copyright">Â© 2025 The Iliad Project</small>
    </div>
</footer>

<script>
    // Theme toggle functionality
    document.addEventListener('DOMContentLoaded', function() {
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        // Function to update logos based on theme
        function updateLogos(isDark) {
            if (isDark) {
                document.getElementById('ude-logo').src = 'images/UDE_dark_mode.svg';
                document.getElementById('sussex-logo').src = 'images/Sussex_dark_mode.svg';
                document.getElementById('unb-logo').src = 'images/UNB_dark_mode.svg';
                document.getElementById('sff-logo').src = 'images/SFF_dark_mode.svg';
            } else {
                document.getElementById('ude-logo').src = 'images/UDE_light_mode.svg';
                document.getElementById('sussex-logo').src = 'images/Sussex_light_mode.svg';
                document.getElementById('unb-logo').src = 'images/UNB_light_mode.svg';
                document.getElementById('sff-logo').src = 'images/SFF_light_mode.svg';
            }
        }

        // Load saved theme preference or detect system preference
        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            html.setAttribute('data-theme', 'dark');
            themeToggle.checked = true;
            updateLogos(true);
        } else if (savedTheme === 'light') {
            html.setAttribute('data-theme', 'light');
            themeToggle.checked = false;
            updateLogos(false);
        } else {
            // No saved preference, detect system preference
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (prefersDark) {
                html.setAttribute('data-theme', 'dark');
                themeToggle.checked = true;
                updateLogos(true);
            } else {
                // System prefers light mode, no data-theme attribute needed
                updateLogos(false);
            }
        }

        // Handle theme toggle
        themeToggle.addEventListener('change', function() {
            if (this.checked) {
                html.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
                updateLogos(true);
            } else {
                html.setAttribute('data-theme', 'light');
                localStorage.setItem('theme', 'light');
                updateLogos(false);
            }
        });

        // Listen for system preference changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
            // Only respond to system changes if no explicit preference is saved
            const savedTheme = localStorage.getItem('theme');
            if (!savedTheme) {
                if (e.matches) {
                    html.setAttribute('data-theme', 'dark');
                    themeToggle.checked = true;
                    updateLogos(true);
                } else {
                    html.removeAttribute('data-theme');
                    themeToggle.checked = false;
                    updateLogos(false);
                }
            }
        });
    });

    // Background Hilbert curve animation
    (function() {
        // Parameters
        const ORDER = 7;
        const STEP_PER_FRAME = 10;
        const LINE_WIDTH = 1;
        const OPACITY = 1;

        const canvas = document.getElementById('background-canvas');
        const ctx = canvas.getContext('2d');

        // Set canvas to full viewport with HiDPI support
        function resizeCanvas() {
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            canvas.width = window.innerWidth * dpr;
            canvas.height = window.innerHeight * dpr;
            canvas.style.width = window.innerWidth + "px";
            canvas.style.height = window.innerHeight + "px";
            ctx.scale(dpr, dpr);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        const SIZE = 1 << ORDER;                 // grid width/height
        const TOTAL = SIZE * SIZE;               // total points
        const W = canvas.clientWidth;
        const H = canvas.clientHeight;
        const MARGIN = Math.min(W, H) * 0.075;
        const step = Math.min((W - 2*MARGIN) / (SIZE - 1), (H - 2*MARGIN) / (SIZE - 1));

        // Map grid (x,y) -> canvas pixels
        function toPx(x, y) {
            // Position from right edge instead of left margin
            const px = W - MARGIN - x * step;
            const py = H - (MARGIN + y * step);
            return [px, py];
        }

        // Rotate a quadrant
        function rot(n, x, y, rx, ry) {
            if (ry === 0) {
                if (rx === 1) {
                    x = n - 1 - x;
                    y = n - 1 - y;
                }
                const t = x; x = y; y = t;
            }
            return [x, y];
        }

        // Convert distance d along the Hilbert curve to (x,y) in [0, SIZE-1]^2
        function d2xy(n, d) {
            let x = 0, y = 0;
            let t = d;
            for (let s = 1; s < n; s <<= 1) {
                const rx = (t >> 1) & 1;
                const ry = (t ^ rx) & 1;
                [x, y] = rot(s, x, y, rx, ry);
                x += s * rx;
                y += s * ry;
                t >>= 2;
            }
            return [x, y];
        }

        // Build the path points - ensure it starts from bottom-right
        const pts = new Array(TOTAL);
        for (let d = 0; d < TOTAL; d++) {
            let [x, y] = d2xy(SIZE, d);
            // No need to mirror since toPx now positions from right edge
            pts[d] = toPx(x, y);
        }

        // Animation state
        let i = 1;
        let animationId;

        function draw() {
            ctx.clearRect(0, 0, canvas.clientWidth, canvas.clientHeight);

            // Draw snake tail with fading alpha
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            const tailStart = 1;
            for (let j = tailStart; j <= i; j++) {
                const a = (j - tailStart) / Math.max(1, (i - tailStart));
                ctx.globalAlpha = Math.pow(1 - a, 1.6) * OPACITY;
                ctx.lineWidth = LINE_WIDTH;
                ctx.beginPath();
                const [x0, y0] = pts[j - 1];
                const [x1, y1] = pts[j];
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.strokeStyle = '#008900';
                ctx.stroke();
            }

            // Advance head
            i += STEP_PER_FRAME;
            if (i >= TOTAL) {
                // Reset animation when complete
                i = 1;
            }

            animationId = requestAnimationFrame(draw);
        }

        // Start animation
        draw();

        // Pause animation when page is not visible
        document.addEventListener('visibilitychange', function() {
            if (document.hidden) {
                cancelAnimationFrame(animationId);
            } else {
                draw();
            }
        });
    })();
</script>

</body>
</html>
