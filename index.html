<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&display=swap">
    <title>Iliad</title>
    <link rel="icon" type="image/svg+xml" href="images/favicon.svg">
    <link rel="icon" type="image/png" href="images/favicon.png">
    <link rel="stylesheet" href="css/style.css">
</head>
<body>
    <canvas id="background-canvas"></canvas>

<header>
    <nav>
        <div class="nav-links">
            <a href="index.html">Home</a>
            <a href="events.html">Events</a>
            <a href="team.html">Team</a>
            <a href="contact.html">Contact</a>
            <a href="about.html">About</a>
        </div>
        <div class="theme-toggle">
            <label class="theme-switch">
                <input type="checkbox" id="theme-toggle">
                <span class="slider"></span>
            </label>
        </div>
    </nav>
</header>

<main>
    <div class="title-main">Iliad</div>

    <p>Iliad is an applied mathematics research nonprofit dedicated to
    advancing foundational research in AI alignment. We organize the eponymous
    <a href="https://www.iliadconference.com/">
    ILIAD conference</a> series, along with a range of other conferences and
    events in the field.</p>

    <!-- TODO: All these logos should be less prominent, somehow, despite them
    putting a floor of 70px (the existing) on their logo heights.-->
    <p>We collaborate with researchers at these academic institutions</p>
    <div class="partner-logos">
        <img src="images/UNB_light_mode.svg" class="partner-logo" id="unb-logo"
        style="position: relative; bottom: 12px;">
        <img src="images/Sussex_light_mode.svg" class="partner-logo"
        id="sussex-logo" style="transform: scale(1.25)">
        <img src="images/UDE_light_mode.svg" class="partner-logo" id="ude-logo"
        style="transform: scale(0.96); position: relative; left: 3px;">
    </div>

    <p>and we are financially supported by</p>
    <div class="partner-logos">
        <img src="images/SFF_light_mode.svg" class="partner-logo" id="sff-logo"
             style="position: relative; left: -4px;">
    </div>
</main>

<footer>
    <div class="footer-content">
        <small class="footer-copyright">Â© 2025 Iliad</small>
    </div>
</footer>

<!-- TODO: Noting that the alpha gradent doesn't work nearly as nicely on
high-DPI mobile screens; some CSS tweaking will be needed to fix that case.-->
<script>
    document.addEventListener('DOMContentLoaded', function() {
        const themeToggle = document.getElementById('theme-toggle');
        const html = document.documentElement;

        function updateLogos(isDark) {
            if (isDark) {
                document.getElementById('ude-logo').src = 'images/UDE_dark_mode.svg';
                document.getElementById('sussex-logo').src = 'images/Sussex_dark_mode.svg';
                document.getElementById('unb-logo').src = 'images/UNB_dark_mode.svg';
                document.getElementById('sff-logo').src = 'images/SFF_dark_mode.svg';
            } else {
                document.getElementById('ude-logo').src = 'images/UDE_light_mode.svg';
                document.getElementById('sussex-logo').src = 'images/Sussex_light_mode.svg';
                document.getElementById('unb-logo').src = 'images/UNB_light_mode.svg';
                document.getElementById('sff-logo').src = 'images/SFF_light_mode.svg';
            }
        }

        const savedTheme = localStorage.getItem('theme');
        if (savedTheme === 'dark') {
            html.setAttribute('data-theme', 'dark');
            themeToggle.checked = true;
            updateLogos(true);
        } else if (savedTheme === 'light') {
            html.setAttribute('data-theme', 'light');
            themeToggle.checked = false;
            updateLogos(false);
        } else {
            // No saved preference, detect system preference
            const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (prefersDark) {
                html.setAttribute('data-theme', 'dark');
                themeToggle.checked = true;
                updateLogos(true);
            } else {
                // System prefers light mode, no data-theme attribute needed
                updateLogos(false);
            }
        }

        // Handle toggle
        themeToggle.addEventListener('change', function() {
            if (this.checked) {
                html.setAttribute('data-theme', 'dark');
                localStorage.setItem('theme', 'dark');
                updateLogos(true);
            } else {
                html.setAttribute('data-theme', 'light');
                localStorage.setItem('theme', 'light');
                updateLogos(false);
            }
        });

        // Listen for system preference changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', function(e) {
            // Only respond to system changes if no explicit preference is saved
            const savedTheme = localStorage.getItem('theme');
            if (!savedTheme) {
                if (e.matches) {
                    html.setAttribute('data-theme', 'dark');
                    themeToggle.checked = true;
                    updateLogos(true);
                } else {
                    html.removeAttribute('data-theme');
                    themeToggle.checked = false;
                    updateLogos(false);
                }
            }
        });
    });

    // Hilbert curve animation
    (function() {
        const footerEl = document.querySelector('footer');
        function dprNow() {
            return Math.max(1, window.devicePixelRatio || 1);
        }
        function getFooterTopPx() {
            const top = footerEl ? footerEl.getBoundingClientRect().top : window.innerHeight;
            return Math.round(Math.max(0, top) * dprNow());
        }
        const ORDER = 7;
        const STEP_PER_FRAME = 10;
        const OPACITY = 1;

        const canvas = document.getElementById('background-canvas');
        const ctx = canvas.getContext('2d');

        const HEAT_SCALE = 0.5;
        const EMIT_R_CSS = 200;
        const BLUR_PX = (matchMedia('(pointer: coarse), (max-width: 768px)').matches ? Math.round(100 * (window.devicePixelRatio || 1) * HEAT_SCALE) : 26);
        const DECAY = 0.996;

        let heatA = document.createElement('canvas');
        let heatB = document.createElement('canvas');
        let heatActx = heatA.getContext('2d');
        let heatBctx = heatB.getContext('2d');
        let dpr = 1, emitR = 20;
        let prevI = 1;
        let heatCenters = [];

        const SIZE = 1 << ORDER;                 // grid width/height
        const TOTAL = SIZE * SIZE;               // total points

        let Wpx = 0, Hpx = 0, pts = [];
        function resizeCanvas() {
            const dpr = Math.max(1, window.devicePixelRatio || 1);
            const cssWidth = window.innerWidth;
            const cssHeight = window.innerHeight;

            canvas.width = Math.round(cssWidth * dpr);
            canvas.height = Math.round(cssHeight * dpr);
            canvas.style.width = cssWidth + "px";
            canvas.style.height = cssHeight + "px";
            ctx.setTransform(1, 0, 0, 1, 0, 0);
            ctx.translate(0.5, 0.5);

            heatA.width = Math.max(1, Math.round(canvas.width * HEAT_SCALE));
            heatA.height = Math.max(1, Math.round(canvas.height * HEAT_SCALE));
            heatB.width = heatA.width;
            heatB.height = heatA.height;
            heatActx.setTransform(1, 0, 0, 1, 0, 0); heatActx.clearRect(0, 0, heatA.width, heatA.height);
            heatBctx.setTransform(1, 0, 0, 1, 0, 0); heatBctx.clearRect(0, 0, heatB.width, heatB.height);

            recomputeGeometry(true);
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);

        function recomputeGeometry(prewarm = false) {
            Wpx = canvas.width;
            Hpx = Math.max(1, getFooterTopPx());
            const MARGIN = Math.min(Wpx, Hpx) * 0.075;
            const step = Math.min(
                (Wpx - 2*MARGIN) / (SIZE - 1),
                (Hpx - 2*MARGIN) / (SIZE - 1)
            );
            const TOP = Hpx - (SIZE - 1) * step;
            pts = new Array(TOTAL);
            for (let d = 0; d < TOTAL; d++) {
                const [gx, gy] = d2xy(SIZE, d);
                pts[d] = [Math.round(Wpx - gx * step), Math.round(TOP + (SIZE - 1 - gy) * step)];
            }

            emitR = Math.max(12, 0.5 * Math.min(Wpx, Hpx) * HEAT_SCALE);
            const [trX, trY] = pts[0];
            heatCenters = [[trX, trY], [Wpx - trX, trY]];

            if (prewarm) {
                heatActx.save();
                heatActx.globalAlpha = 1.0;
                for (const [cx, cy] of heatCenters) stampHeat(cx, cy);
                heatActx.restore();
                for (let k = 0; k < 40; k++) diffuseHeat();
            }

        }

        function stampHeat(x, y) {
            const hx = x * HEAT_SCALE, hy = y * HEAT_SCALE;
            const g = heatActx.createRadialGradient(hx, hy, 0, hx, hy, emitR);
            g.addColorStop(0.0, 'rgba(0,0,0,0.95)');
            g.addColorStop(1.0, 'rgba(0,0,0,0.0)');
            heatActx.globalCompositeOperation = 'source-over';
            heatActx.fillStyle = g;
            heatActx.beginPath(); heatActx.arc(hx, hy, emitR, 0, Math.PI * 2);
            heatActx.fill();
        }

        function diffuseHeat() {
            heatBctx.save();
            heatBctx.filter = `blur(${BLUR_PX}px)`;
            heatBctx.globalCompositeOperation = 'copy';
            heatBctx.globalAlpha = DECAY;
            heatBctx.drawImage(heatA, 0, 0);
            heatBctx.restore();
            [heatA, heatB] = [heatB, heatA];
            [heatActx, heatBctx] = [heatBctx, heatActx];
        }

        // Rotate a quadrant
        function rot(n, x, y, rx, ry) {
            if (ry === 0) {
                if (rx === 1) {
                    x = n - 1 - x;
                    y = n - 1 - y;
                }
                const t = x; x = y; y = t;
            }
            return [x, y];
        }

        // Convert distance d along the Hilbert curve to (x,y) in [0, SIZE-1]^2
        function d2xy(n, d) {
            let x = 0, y = 0;
            let t = d;
            for (let s = 1; s < n; s <<= 1) {
                const rx = (t >> 1) & 1;
                const ry = (t ^ rx) & 1;
                [x, y] = rot(s, x, y, rx, ry);
                x += s * rx;
                y += s * ry;
                t >>= 2;
            }
            return [x, y];
        }

        // Animation state
        let i = 1;
        let animationId;

        let scrollRaf = false;

        function renderFrame() {
            recomputeGeometry(false);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.lineWidth = 1;
            ctx.lineCap = 'butt';
            ctx.lineJoin = 'miter';
            ctx.strokeStyle = '#00E000';

            const tailStart = 1;
            const MID = Math.trunc(Wpx / 2);

            ctx.save();
            ctx.beginPath();
            ctx.rect(MID, 0, Wpx - MID, Hpx);
            ctx.clip();
            for (let j = tailStart; j <= i; j++) {
                const [x0, y0] = pts[j - 1];
                const [x1, y1] = pts[j];

                // Right curve
                ctx.beginPath();
                ctx.moveTo(x0, y0);
                ctx.lineTo(x1, y1);
                ctx.stroke();
            }
            ctx.restore();

            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 0, MID, Hpx);
            ctx.clip();
            for (let j = tailStart; j <= i; j++) {
                const [x0, y0] = pts[j - 1];
                const [x1, y1] = pts[j];

                // Left curve
                ctx.beginPath();
                ctx.moveTo(Wpx - x0, y0);
                ctx.lineTo(Wpx - x1, y1);
                ctx.stroke();
            }
            ctx.restore();

            heatActx.save();
            heatActx.globalAlpha = 0.25;
            for (const [cx, cy] of heatCenters) stampHeat(cx, cy);
            heatActx.restore();

            diffuseHeat();
            ctx.save();
            ctx.globalCompositeOperation = 'destination-in';
            ctx.drawImage(heatA, 0, 0, heatA.width, heatA.height, 0, 0, canvas.width, canvas.height);
            ctx.restore();
        }
        
        function draw() {
            renderFrame();
            i = Math.min(TOTAL - 1, i + STEP_PER_FRAME);
            if (i >= TOTAL - 1) {
                return;
            }
            animationId = requestAnimationFrame(draw);
        }


        // Start animation
        draw();

        function rerenderOnScroll() {
            if (scrollRaf) return;
            scrollRaf = true;
            requestAnimationFrame(() => {
                scrollRaf = false;
                recomputeGeometry(false);
                renderFrame();
            });
            }
        window.addEventListener('scroll', rerenderOnScroll, { passive: true });
        if (window.visualViewport) {
            window.visualViewport.addEventListener('scroll', rerenderOnScroll, { passive: true });
        }
        if (window.visualViewport) {
            window.visualViewport.addEventListener('resize', resizeCanvas);
        }
        (function watchDPR() {
            const q = matchMedia(`(resolution: ${window.devicePixelRatio || 1}dppx)`);
            q.addEventListener('change', () => { resizeCanvas(); watchDPR(); });
        })();
    })();
</script>

</body>
</html>
